---
title: "LGM Abies"
author: "Nikos Tourvas"
date: "Date (ISO 8601): `r format(Sys.time(), '%Y-%m-%d')`"
bibliography: My_Collection.bib
output:
  html_document:
    theme: united
    toc: yes
  word_document: 
    toc: yes
---

### Load libraries
```{r}
suppressPackageStartupMessages({
  library(popprxl)
  library(hierfstat)
  library(magrittr)
  library(pegas)
  library(mmod)
  library(ape)
  library(phangorn)
  library(tidyverse)
  library(ggplot2)
  library(lattice)
  library(factoextra)
  library(ggord)
  library(RColorBrewer)
  library(ggcompoplot)
})
```

# Import data set
```{r eval=FALSE, include=FALSE}
vignette('poppr_manual')
```

```{r import, cache=T}
obj <- read.genalexcel(
  "LGM_DE_SI_GR_final.xlsx", 
  sheet = "Abies", genclone = F)

# stratify data set
splitStrata(obj) <- ~Country/Pop
```

### Check for missing data
```{r missing, cache=F, fig.width=10, dpi=300}
capture.output(
info_table(obj, type = "missing", plot = TRUE),
file='NUL') 
# capture.output is used to hide printing of the table on the console
```

```{r subset}
# Subset dataset (as standalone function or nested)
# s <- popsub(Abies_LifeGenMon, sublist =
#          c("Adult_GR_1_IN", "Adult_GR_1_EX"))
```

### Produce table
```{r table, cache=TRUE}
div <- poppr(obj, plot=F)
div <- div[,!names(div)%in%c("File","Hexp")]
Ho <- colMeans(basic.stats(obj)$Ho, na.rm=T)
Hs <- colMeans(basic.stats(obj)$Hs, na.rm=T)
Fis <- colMeans(basic.stats(obj)$Fis, na.rm=T)
div2 <- data.frame(Ho=Ho, Hs=Hs, Fis=Fis)
tots <- colMeans(div2) # WRONG!!! TOTAL FIS SHOULD BE CALCULATED FROM MEAN HO AND MEAN Hs
div2 <- rbind(div2, tots)
div <- cbind(div, div2)
PA <- rowSums(private_alleles(obj, count.alleles=F))
PA <- data.frame(PA)
PA <- rbind(PA, Total=colSums(PA))
div <- cbind(div, PA)
row.names(div) <- NULL
is.num <- sapply(div, is.numeric)
div[is.num] <- lapply(div[is.num], round, 3)
knitr::kable(div)
```



### Summary statistics
```{r summary, fig.width=10, out.width="70%", dpi=300, cache=T}
setPop(obj) <- ~Country/Pop

toto <- summary(obj)

# num.al= data.frame(name = names(toto$loc.n.all), alleles = toto$loc.n.all)
barplot(toto$loc.n.all, ylab="Number of alleles", main="Number of alleles per locus")
# knitr::kable(num.al, caption = "Number of alleles per locus")
toto$loc.n.all
```


### Private alleles per population
```{r private_pops, cache=TRUE, dpi=300, fig.width=8.5}
private <- private_alleles(obj, report = "data.frame")
ggplot(private) + geom_tile(aes(x = population, 
                                y = allele, 
                                fill = count)) +
  ggtitle("Private alleles per population")
```

```{r eval=FALSE, cache=TRUE, include=FALSE}
pal <- as.data.frame(private_alleles(obj, count.alleles = FALSE))
  pal$Sum <- rowSums(pal)

knitr::kable(pal)
```

### Private alleles per country
```{r private_countries, cache=TRUE, dpi=300, fig.height=8}
private_countries <- private_alleles(obj, alleles ~ Country, report = "data.frame")
ggplot(private_countries) + geom_tile(aes(x = population, 
                                          y = allele, 
                                          fill = count)) +
  ggtitle("Private alleles per country")

pal_countries <- as.data.frame(private_alleles(obj, locus ~ Country, count.alleles = FALSE))
  pal_countries$Sum <- rowSums(pal_countries)

knitr::kable(pal_countries, caption = "Private alleles per country")
```

### Hardy - Weinberg equilibrium
```{r HWE, fig.width=9, dpi=300, cache=TRUE}
(hw.obj <- seppop(obj) %>% 
  lapply(hw.test, B = 1000))
# seppop: calculates p-value for each locus of every pop
# B: number of permutations

# Isolate p-values either from chi2 test (j=3) or 
# from exact test (j=4)
hw.mat <- sapply(hw.obj, "[", i = TRUE, j = 4)
# Take the third/fourth column with all rows

# Multiple test correction (Holm-Bonferroni)
hw.holm.values <- p.adjust(hw.mat, method = "holm")
locinames <- rownames(hw.mat)
popnames <- colnames(hw.mat)

hw.holm.mat <- matrix(nrow = length(locNames(obj)),
                      ncol = length(popNames(obj)),
                      data = hw.holm.values, byrow = F)
rownames(hw.holm.mat) <- locinames
colnames(hw.holm.mat) <- popnames

levelplot(t(hw.holm.mat), aspect = "fill", xlab="Pop", ylab="Marker", main = "HWE p-values after Holm-Bonferroni correction")

knitr::kable(hw.holm.mat, caption = "HWE p-values after Holm-Bonferroni correction")
```

```{r basic.stats, cache=T}
colMeans(basic.stats(obj)$Fis, na.rm = T)
# pops <- seppop(obj) 
# stats <- list()
# for(i in 1:length(pops)){
#   stats[[i]] <- basic.stats(pops[[i]])
# }
```

```{r ar_pops, dpi=96, cache=T}
setPop(obj) <- ~Country/Pop

ar <- allelic.richness(obj)

# create data.frame for ggplot2
ar[["Ar"]] <- as.data.frame(ar[["Ar"]])
colnames(ar[["Ar"]]) <- popNames(obj)
ar_table <- ar[["Ar"]] # to be printed by kable
ar[["Ar"]]$locus <- rownames(ar[["Ar"]])
ar[["Ar"]] <- gather(ar[["Ar"]], Population, Ar, -locus)

ar_table["Mean", ] <- colMeans(ar_table) # a row countaining means
knitr::kable(ar_table, caption = "Allelic richness per population")


title <- paste("Allelic richness per population (rarefaction = ", ar[["min.all"]], "genes)")

y_axis <- seq(0, 100, 2)

ggplot(ar[["Ar"]], aes(x = Population, y = Ar)) +
  geom_boxplot() +
  scale_y_continuous(name = "Allelic richness", breaks = y_axis) +
  theme_classic() +
  stat_summary(fun.y=mean, geom="point", shape=4, size=2, color="black", fill="black") +
  ggtitle(title)
```

```{r ar_country, dpi=96, cache=T}
setPop(obj) <- ~Country

ar <- allelic.richness(obj)

# create data.frame for ggplot2
ar[["Ar"]] <- as.data.frame(ar[["Ar"]])
colnames(ar[["Ar"]]) <- popNames(obj)
ar_table <- ar[["Ar"]] # to be printed by kable
ar[["Ar"]]$locus <- rownames(ar[["Ar"]])
ar[["Ar"]] <- gather(ar[["Ar"]], Population, Ar, -locus)

ar_table["Mean", ] <- colMeans(ar_table)
knitr::kable(ar_table, caption = "Allelic richness per country")


title <- paste("Allelic richness per population (rarefaction = ", ar[["min.all"]], "genes)")

y_axis <- seq(0, 100, 2)

ggplot(ar[["Ar"]], aes(x = Population, y = Ar)) +
  geom_boxplot() +
  scale_y_continuous(name = "Allelic richness", breaks = y_axis) +
  theme_classic() +
  stat_summary(fun.y=mean, geom="point", shape=4, size=2, color="black", fill="black") +
  ggtitle(title)
```

# Genetic differentiation

### Cavalli-Sforza and Edwards Chord distance
```{r cavalli-sforza_1, fig.width = 10, dpi=300, cache=T}
# https://groups.google.com/forum/#!topic/poppr/vEQ8vb2oObQ

# set appropriate hierarchy
setPop(obj) <- ~Country/Pop

# create hierfstat input file
obj_hier <- genind2hierfstat(obj)

# create cav-sf distance table
cav_sf <- genet.dist(obj_hier, method = "Dch")
cav_sf <- as.matrix(cav_sf)
pop_vector <- popNames(obj)
colnames(cav_sf) <- pop_vector
rownames(cav_sf) <- pop_vector


# Get lower triangle of the matrix
  get_lower_tri<-function(matrix){
    matrix[upper.tri(matrix)] <- NA
    return(matrix)
  }

# print table with knitr  
cav_sf <- get_lower_tri(cav_sf)  
options(knitr.kable.NA = '')  
knitr::kable(cav_sf, caption = "Cavalli-Sforza and Edwards Chord distance between populations") 
  
# create cav-sf distance table
  # set appropriate hierarchy
setPop(obj) <- ~Country

cav_sf_country <- genet.dist(obj, method = "Dch")
cav_sf_country <- as.matrix(cav_sf_country)
pop_vector <- popNames(obj)
colnames(cav_sf_country) <- pop_vector
rownames(cav_sf_country) <- pop_vector


# print table with knitr  
cav_sf_country<- get_lower_tri(cav_sf_country)  
options(knitr.kable.NA = '')  
knitr::kable(cav_sf_country, caption = "Cavalli-Sforza and Edwards Chord distance between countries")
```

```{r cavalli-sforza_2, fig.width = 10, dpi=300, cache=T}
# functions
fungen <- function(pop_column) {
  force(pop_column)
  function(x) {
    dat <- cbind(pop_column, x)
    res <- nj(genet.dist(dat, method = "Dch"))
    res$tip.label <- levels(dat[[1]])
    res
  }
}

genet.tree.nj <- fungen(obj_hier[1])

fungen <- function(pop_column) {
  force(pop_column)
  function(x) {
    dat <- cbind(pop_column, x)
    res <- upgma(genet.dist(dat, method = "Dch"))
    res$tip.label <- levels(dat[[1]])
    res
  }
}

genet.tree.upgma <- fungen(obj_hier[1])




# Create tree
tree_upgma <- genet.tree.upgma(obj_hier[-1])
num_boot <- 100
tree_upgma$node.label <- boot.phylo(phy = tree_upgma, x = obj_hier[-1],
                                    FUN = genet.tree.upgma, B = num_boot
                                    , jumble = FALSE
                                    , mc.cores = 4  # does not work on Windows
                                    )

# Display tree
nodelabs <- (100 / num_boot) *  tree_upgma$node.label
nodelabs[nodelabs < 50] <- NA
plot.phylo(tree_upgma, cex = 1, font = 2, adj = 0, xpd = TRUE,
           label.offset = 0.0125)
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8,
           font = 3, xpd = TRUE)
title(main = "Dendrogram based on Cavalli-Sforza and Edwards Chord distance",
      sub = "method: UPGMA, 1000 Bootstraps")
axisPhylo(side = 1)



# Create tree
tree_nj <- genet.tree.nj(obj_hier[-1])
num_boot <- 100 # number of bootstraps
tree_nj$node.label <- boot.phylo(phy = tree_nj, x = obj_hier[-1], 
                                 FUN = genet.tree.nj, B = num_boot
                                 , jumble = FALSE
                                 , mc.cores = 4  # does not work on Windows
)

# Display tree
nodelabs <- (100 / num_boot) *  tree_nj$node.label
nodelabs[nodelabs < 50] <- NA # hide values below 50
plot.phylo(tree_nj, cex = 1, font = 2, adj = 0, xpd = TRUE, 
           label.offset = 0.0125, type = "phylogram")
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8, 
           font = 3, xpd = TRUE)
title(main = "Dendrogram based on Cavalli-Sforza and Edwards Chord distance",
      sub = "method: Neighbor-Joining, 1000 Bootstraps")
add.scale.bar(lwd = 2, length = 0.05, x = 0.24, y=1)
# to find optimal position for scale bar write on the console:
# locator(1)
# and click on the plot where you want to place the scale bar
```

### Nei distance 1972 1978

```{r nei_hierfstat, cache=T}
# set appropriate hierarchy
setPop(obj) <- ~Country/Pop
# create nei distance table
nei <- genet.dist(obj, method = "Ds")
nei <- as.matrix(nei)
pop_vector <- popNames(obj)
colnames(nei) <- pop_vector
rownames(nei) <- pop_vector


# print table with knitr  
nei<- get_lower_tri(nei)  
knitr::kable(nei, caption = "Nei's Standard genetic distance between populations")

# create nei distance table
# set appropriate hierarchy
setPop(obj) <- ~Country

nei_country <- genet.dist(obj, method = "Ds")
nei_country <- as.matrix(nei_country)
pop_vector <- popNames(obj)
colnames(nei_country) <- pop_vector
rownames(nei_country) <- pop_vector

# print table with knitr  
nei_country<- get_lower_tri(nei_country) 
knitr::kable(nei_country, caption = "Nei's Standard genetic distance between countries")
```


```{r nei_poppr, fig.width = 10, dpi=300, cache=T}
set.seed(1994)


tree_upgma <- aboot(obj, strata = ~Country/Pop, sample = 1000, 
                    cutoff = 50, distance = "nei.dist", tree = "upgma",                     showtree = F)

nodelabs <- round(tree_upgma$node.label, 2)
plot.phylo(tree_upgma, cex = 1, font = 2, adj = 0, xpd = TRUE, 
label.offset = 0.0125)
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8, 
font = 3, xpd = TRUE)
title(main = "Dendrogram based on Nei's standard genetic distance",
      sub = "method: UPGMA, 1000 Bootstraps")
axisPhylo(side = 1)



tree_nj <- aboot(obj, strata = ~Country/Pop, sample = 1000, cutoff = 50,
                 distance = "nei.dist", tree = "nj", showtree = F)

nodelabs <- round(tree_nj$node.label, 2)
plot.phylo(tree_nj, cex = 1, font = 2, adj = 0, xpd = TRUE, 
label.offset = 0.0125)
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8, 
font = 3, xpd = TRUE)
title(main = "Dendrogram based on Nei's standard genetic distance",
      sub = "method: Neighbor-Joining, 1000 Bootstraps")
add.scale.bar(lwd = 2, length = 0.01, x = 0.24, y=1)
```

### Principal Component Analysis
```{r pca, dpi=72, cache=T}
setPop(obj) <- ~Country/Pop

# In case there are missing data, replace with mean
X <- tab(obj, freq = TRUE, NA.method = "mean") 

pca.obj <- dudi.pca(X, scale = FALSE, scannf = FALSE, nf = 3)

fviz_eig(pca.obj, main = "Scree plot of PCA")
```

```{r pca_plots, fig.width=10, dpi=300, cache=T}
ggord(pca.obj, pop(obj), arrow = NULL, txt = NULL, grp_title="Populations", ellipse=T, poly=FALSE, size=2, alpha=.8, coord_fix=F, axes = c("1", "2")) +
  geom_hline(yintercept=0,linetype=2) + 
  geom_vline(xintercept=0,linetype=2) +
  ggtitle("Principal Component Analysis")

ggord(pca.obj, pop(obj), arrow = NULL, txt = NULL, grp_title="Populations", ellipse=T, poly=FALSE, size=2, alpha=.8, coord_fix=F, axes = c("1", "3")) +
  geom_hline(yintercept=0,linetype=2) + 
  geom_vline(xintercept=0,linetype=2) +
  ggtitle("Principal Component Analysis")
  #scale_colour_brewer(palette="Set3")

loadingplot(pca.obj$c1^2, threshold = 0.05)
```

### Correspondence Analysis
```{r ca, dpi=72, cache=T}
ca1 <- dudi.coa(tab(obj, freq = TRUE, NA.method = "mean"), scannf=FALSE,nf=3) 

fviz_eig(ca1, main = "Scree plot of CA")
```

```{r ca_plots, fig.width=10, dpi=300, cache=T}
# devtools::install_github('fawda123/ggord')

ggord(ca1, pop(obj), arrow = NULL, txt = NULL, grp_title="Populations", ellipse=T, poly=FALSE, size=2, alpha=.8, coord_fix=F, axes = c("1", "2")) +
  geom_hline(yintercept=0,linetype=2) + 
  geom_vline(xintercept=0,linetype=2) +
  ggtitle("Correspondence Analysis") 

ggord(ca1, pop(obj), arrow = NULL, txt = NULL, grp_title="Populations", ellipse=T, poly=FALSE, size=2, alpha=.8, coord_fix=F, axes = c("1", "3")) +
  geom_hline(yintercept=0,linetype=2) + 
  geom_vline(xintercept=0,linetype=2) +
  ggtitle("Correspondence Analysis")
  #scale_colour_brewer(palette="Set3")

loadingplot(ca1$c1^2, threshold = 8)
```

### DAPC
```{r k-means, cache=T, dpi=300}
setPop(obj) <- ~Country/Pop

# based on https://github.com/thibautjombart/adegenet/blob/master/tutorials/tutorial-dapc.pdf
grp <- find.clusters(obj, max.n.clust=40, n.pca = 1000, n.clust = 3)
```
BIC: Bayesian Information Criterion

```{r dapc, fig.width=10, cache=T, dpi=300}
set.seed(1994)

assingment_table <- table(pop(obj), grp$grp)
knitr::kable(assingment_table, caption = "actual groups (”ori”) vs inferred groups (”inf”)")

table.value(table(pop(obj), grp$grp), col.lab=paste("inf", 1:9), row.lab=paste("ori", 1:9))

dapc2 <- dapc(obj, n.da=100, n.pca=100)
temp <- optim.a.score(dapc2)

dapc1 <- dapc(obj, grp$grp, n.pca = temp$best, n.da = 10)

scatter(dapc1, posi.da="bottomright", bg="white", pch=17:19, cstar=0, scree.pca=TRUE, posi.pca="bottomleft", n.pca=30, n.da=10)

# devtools::install_github("zkamvar/ggcompoplot")
ggcompoplot(dapc1, obj, cols = 3) + 
  theme(axis.text.x = element_blank()) +
  scale_fill_brewer(palette = "Set2") +
  ylab("membership probability")
```

### AMOVA

```{r amova, cache=T}
poppr.amova(obj, ~Country, within = F)
```

### Hierarchical AMOVA
```{r amova_within, cache=T}
setPop(obj) <- ~Country/Pop

poppr.amova(obj, ~Country/Pop, within = F)
```

```{r amova_arlequin, eval=FALSE, cache=T, include=FALSE}
### Hierarchical AMOVA - within variation included (as calculated using Arlequin)
poppr.amova(obj, ~Country/Pop, within = T)
```

### Hierarchical F~ST~ [@Goudet2004]
```{r hier_fst, eval=FALSE, include=FALSE}
varcomp.glob(obj, levels = Country,Pop)
```


### Left to do
check Jombard tutorial "Tutorial-Basics Copy"
null alleles
standard parameters - se, sd, 95%cis
Fst table
geneflow - migration 1/4fst
ne estimation
STRUCTURE
MIGRATE
BAYESCAN
IBD - Mantel test
genepop - LD
ia - LD
test.within - hierarchical Fst -  
- 


Make table with Ho He using adegenet's summary function. Also include in the table HWE , N of alleles, Ne of alleles

In F~ST~ it would be advisable to also display standard error (Meirmans)

Bootstraping randomly sampling loci with replacement because including or excluding a single locus entails a substantial impact in calculated statistics. Maybe with boot.ppfis and boot.ppfst???
seppop
lapply(obj_hier, boot.ppfis)

# Reproducibility
```{r reproducibility}
devtools::session_info()
```

# Bibliography
